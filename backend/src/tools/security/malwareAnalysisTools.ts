import { models } from '../../database/models';
import { Op } from 'sequelize';
import conversationalIntelligence from '../../services/conversationalIntelligenceService';

/**
 * Malware Analysis Tools for AI Chat System
 * Provides intelligent malware incident analysis with interactive capabilities
 */

const MALWARE_ANALYSIS_TOOLS = [
  {
    type: "function",
    function: {
      name: "search_similar_malware_incidents",
      description: "Find similar malware incidents and ask user to select for detailed analysis",
      category: "Malware Analysis",
      parameters: {
        type: "object",
        properties: {
          indicators: {
            type: "array",
            items: { type: "string" },
            description: "IOC indicators like hashes, domains, IPs to search for"
          },
          timeRange: {
            type: "string",
            enum: ["24h", "7d", "30d", "90d"],
            default: "30d",
            description: "Time range for malware incident search"
          },
          malwareType: {
            type: "string",
            enum: ["all", "ransomware", "trojan", "virus", "rootkit", "spyware", "adware"],
            default: "all",
            description: "Type of malware to focus the search on"
          },
          similarityThreshold: {
            type: "number",
            minimum: 0.1,
            maximum: 1.0,
            default: 0.7,
            description: "Similarity threshold for matching incidents"
          },
          organizationId: {
            type: "string",
            description: "Organization ID for data access"
          },
          conversationId: {
            type: "string",
            description: "Conversation ID for interactive workflow"
          }
        },
        required: ["organizationId", "conversationId"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "analyze_malware_incident_interactive",
      description: "Perform deep analysis of selected malware incident with user interaction",
      category: "Malware Analysis",
      parameters: {
        type: "object",
        properties: {
          incidentId: {
            type: "string",
            description: "Incident ID to analyze in detail"
          },
          analysisType: {
            type: "string",
            enum: ["ioc_correlation", "timeline_analysis", "impact_assessment", "attribution", "ttps"],
            default: "ioc_correlation",
            description: "Type of malware analysis to perform"
          },
          includeNetworkAnalysis: {
            type: "boolean",
            default: true,
            description: "Include network traffic and communication analysis"
          },
          includeBehaviorAnalysis: {
            type: "boolean",
            default: true,
            description: "Include behavioral analysis and file system changes"
          },
          organizationId: {
            type: "string",
            description: "Organization ID for data access"
          },
          conversationId: {
            type: "string",
            description: "Conversation ID for interactive workflow"
          }
        },
        required: ["organizationId", "conversationId"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "get_malware_trends",
      description: "Get trending malware patterns and emerging threats",
      category: "Threat Intelligence",
      parameters: {
        type: "object",
        properties: {
          timeRange: {
            type: "string",
            enum: ["7d", "30d", "90d", "180d"],
            default: "30d",
            description: "Time range for trend analysis"
          },
          trendType: {
            type: "string",
            enum: ["volume", "family", "geography", "target_industry"],
            default: "volume",
            description: "Type of trend analysis"
          },
          organizationId: {
            type: "string",
            description: "Organization ID for data access"
          }
        },
        required: ["organizationId"]
      }
    }
  }
];

interface MalwareIncident {
  id: string;
  incidentId: string;
  title: string;
  description: string;
  category: string;
  severity: string;
  status: string;
  detectedAt: Date;
  createdAt: Date;
  indicators?: any[];
  affectedAssets?: any[];
  malwareFamily?: string;
}

class MalwareAnalysisExecutor {
  private Alert: any;
  private Incident: any;
  private Asset: any;
  private IOC: any;

  constructor() {
    const { Alert, Incident, Asset, IOC } = models as any;
    this.Alert = Alert;
    this.Incident = Incident;
    this.Asset = Asset;
    this.IOC = IOC;
  }

  /**
   * Search for similar malware incidents with interactive selection
   */
  async search_similar_malware_incidents(params: any): Promise<any> {
    const {
      indicators = [],
      timeRange = '30d',
      malwareType = 'all',
      similarityThreshold = 0.7,
      organizationId,
      conversationId
    } = params;

    try {
      // Calculate time range
      const timeRangeMs = this.parseTimeRange(timeRange);
      const startDate = new Date(Date.now() - timeRangeMs);

      // Build search query
      const whereClause: any = {
        organizationId,
        createdAt: { [Op.gte]: startDate },
        category: malwareType === 'all' ? { [Op.like]: '%malware%' } : { [Op.like]: `%${malwareType}%` }
      };

      // Add indicator search if provided
      if (indicators.length > 0) {
        whereClause[Op.or] = indicators.map((indicator: string) => ({
          [Op.or]: [
            { description: { [Op.iLike]: `%${indicator}%` } },
            { title: { [Op.iLike]: `%${indicator}%` } }
          ]
        }));
      }

      // Find matching incidents
      const incidents = await this.Incident.findAll({
        where: whereClause,
        order: [['createdAt', 'DESC']],
        limit: 10,
        include: [
          { model: this.Alert, as: 'alerts' },
          { model: this.Asset, as: 'affectedAssets' }
        ]
      });

      if (incidents.length === 0) {
        return {
          success: true,
          data: {
            incidents: [],
            searchCriteria: { indicators, timeRange, malwareType },
            totalFound: 0
          },
          message: `No malware incidents found matching your criteria in the last ${timeRange}.`
        };
      }

      // Format incidents for user selection
      const formattedIncidents = incidents.map((incident: any) => ({
        id: incident.id,
        incidentId: incident.incidentId,
        title: incident.title,
        category: incident.category,
        severity: incident.severity,
        status: incident.status,
        detectedAt: incident.detectedAt,
        alertCount: incident.alerts?.length || 0,
        affectedAssets: incident.affectedAssets?.length || 0,
        malwareFamily: this.extractMalwareFamily(incident.title, incident.description)
      }));

      // Generate interactive selection prompt
      const selectionPrompt = this.formatMalwareIncidentSelection(formattedIncidents);

      return {
        success: true,
        requiresUserInput: true,
        data: {
          incidents: formattedIncidents,
          searchCriteria: { indicators, timeRange, malwareType },
          totalFound: incidents.length
        },
        message: selectionPrompt,
        nextStep: 'awaiting_incident_selection'
      };

    } catch (error: any) {
      console.error('Error searching malware incidents:', error);
      return {
        success: false,
        error: 'Failed to search malware incidents: ' + (error?.message || 'Unknown error')
      };
    }
  }

  /**
   * Analyze selected malware incident in detail
   */
  async analyze_malware_incident_interactive(params: any): Promise<any> {
    const {
      incidentId,
      analysisType = 'ioc_correlation',
      includeNetworkAnalysis = true,
      includeBehaviorAnalysis = true,
      organizationId,
      conversationId
    } = params;

    try {
      if (!incidentId) {
        return {
          success: false,
          error: 'Incident ID is required for analysis'
        };
      }

      // Fetch detailed incident data
      const incident = await this.Incident.findOne({
        where: { 
          [Op.or]: [
            { id: incidentId },
            { incidentId: incidentId }
          ],
          organizationId 
        },
        include: [
          { model: this.Alert, as: 'alerts' },
          { model: this.Asset, as: 'affectedAssets' }
        ]
      });

      if (!incident) {
        return {
          success: false,
          error: `Malware incident ${incidentId} not found`
        };
      }

      // Perform analysis based on type
      const analysis = await this.performMalwareAnalysis(
        incident, 
        analysisType, 
        includeNetworkAnalysis, 
        includeBehaviorAnalysis
      );

      return {
        success: true,
        data: {
          incident: {
            incidentId: incident.incidentId,
            title: incident.title,
            severity: incident.severity,
            category: incident.category,
            timeline: {
              detected: incident.detectedAt,
              reported: incident.createdAt,
              lastUpdate: incident.updatedAt
            }
          },
          analysis,
          analysisType,
          generatedAt: new Date().toISOString()
        },
        message: `✅ **Malware Analysis Complete**\n\n**Incident**: ${incident.incidentId} - ${incident.title}\n**Analysis Type**: ${analysisType.replace(/_/g, ' ').toUpperCase()}\n**Generated**: ${new Date().toLocaleString()}\n\nDetailed malware analysis has been completed with ${analysis.indicators?.length || 0} IOCs analyzed and ${analysis.recommendations?.length || 0} recommendations generated.`
      };

    } catch (error: any) {
      console.error('Error analyzing malware incident:', error);
      return {
        success: false,
        error: 'Failed to analyze malware incident: ' + (error?.message || 'Unknown error')
      };
    }
  }

  /**
   * Get malware trends and patterns
   */
  async get_malware_trends(params: any): Promise<any> {
    const {
      timeRange = '30d',
      trendType = 'volume',
      organizationId
    } = params;

    try {
      const timeRangeMs = this.parseTimeRange(timeRange);
      const startDate = new Date(Date.now() - timeRangeMs);

      // Base query for malware incidents
      const baseWhere = {
        organizationId,
        category: { [Op.like]: '%malware%' },
        createdAt: { [Op.gte]: startDate }
      };

      let trendData;

      switch (trendType) {
        case 'volume':
          trendData = await this.getMalwareVolumeTrends(baseWhere, timeRange);
          break;
        case 'family':
          trendData = await this.getMalwareFamilyTrends(baseWhere);
          break;
        case 'geography':
          trendData = await this.getMalwareGeographyTrends(baseWhere);
          break;
        case 'target_industry':
          trendData = await this.getMalwareTargetTrends(baseWhere);
          break;
        default:
          trendData = await this.getMalwareVolumeTrends(baseWhere, timeRange);
      }

      return {
        success: true,
        data: {
          trendType,
          timeRange,
          trends: trendData,
          summary: this.generateTrendSummary(trendData, trendType),
          generatedAt: new Date().toISOString()
        }
      };

    } catch (error: any) {
      console.error('Error getting malware trends:', error);
      return {
        success: false,
        error: 'Failed to get malware trends: ' + (error?.message || 'Unknown error')
      };
    }
  }

  /**
   * Parse time range string to milliseconds
   */
  private parseTimeRange(timeRange: string): number {
    const ranges: Record<string, number> = {
      '24h': 24 * 60 * 60 * 1000,
      '7d': 7 * 24 * 60 * 60 * 1000,
      '30d': 30 * 24 * 60 * 60 * 1000,
      '90d': 90 * 24 * 60 * 60 * 1000,
      '180d': 180 * 24 * 60 * 60 * 1000
    };
    return ranges[timeRange] ?? (30 * 24 * 60 * 60 * 1000);
  }

  /**
   * Format malware incident selection prompt
   */
  private formatMalwareIncidentSelection(incidents: any[]): string {
    let prompt = "🦠 **Malware Incident Analysis**\n\n";
    prompt += "I found several malware incidents for analysis. Which one would you like me to analyze?\n\n";
    
    incidents.forEach((inc, index) => {
      const severityIcon = this.getSeverityIcon(inc.severity);
      const categoryIcon = this.getMalwareIcon(inc.category);
      prompt += `${index + 1}. **${inc.incidentId}** ${severityIcon}${categoryIcon} ${inc.title}\n`;
      prompt += `   🕒 ${inc.detectedAt ? new Date(inc.detectedAt).toLocaleDateString() : 'Unknown'} | `;
      prompt += `🚨 ${inc.alertCount} alerts | 💻 ${inc.affectedAssets} assets`;
      if (inc.malwareFamily) {
        prompt += ` | 🦠 ${inc.malwareFamily}`;
      }
      prompt += `\n\n`;
    });
    
    prompt += "Please tell me the incident number (1, 2, 3...) or incident ID you'd like me to analyze.";
    return prompt;
  }

  /**
   * Get severity icon for display
   */
  private getSeverityIcon(severity: string): string {
    const icons: Record<string, string> = {
      critical: '🚨',
      high: '⚠️',
      medium: '📋',
      low: '📝'
    };
    return icons[severity] || '📋';
  }

  /**
   * Get malware category icon
   */
  private getMalwareIcon(category: string): string {
    const icons: Record<string, string> = {
      ransomware: '🔐',
      trojan: '🐎',
      virus: '🦠',
      rootkit: '👻',
      spyware: '👀',
      adware: '📢'
    };
    
    for (const [key, icon] of Object.entries(icons)) {
      if (category.toLowerCase().includes(key)) {
        return icon;
      }
    }
    return '🦠';
  }

  /**
   * Extract malware family from incident details
   */
  private extractMalwareFamily(title: string, description: string): string | undefined {
    const text = `${title} ${description}`.toLowerCase();
    const families = [
      'wannacry', 'petya', 'locky', 'cerber', 'ryuk', 'maze', 'revil',
      'emotet', 'trickbot', 'qakbot', 'dridex', 'zeus', 'banking trojan',
      'stuxnet', 'conficker', 'mirai', 'gh0st', 'poison ivy'
    ];
    
    for (const family of families) {
      if (text.includes(family)) {
        return family.charAt(0).toUpperCase() + family.slice(1);
      }
    }
    return undefined;
  }

  /**
   * Perform detailed malware analysis
   */
  private async performMalwareAnalysis(
    incident: any, 
    analysisType: string, 
    includeNetworkAnalysis: boolean, 
    includeBehaviorAnalysis: boolean
  ): Promise<any> {
    const analysis: any = {
      type: analysisType,
      timestamp: new Date().toISOString()
    };

    switch (analysisType) {
      case 'ioc_correlation':
        analysis.indicators = await this.analyzeIOCs(incident);
        analysis.correlations = await this.findIOCCorrelations(incident);
        break;
      
      case 'timeline_analysis':
        analysis.timeline = await this.buildIncidentTimeline(incident);
        analysis.phases = this.identifyAttackPhases(incident);
        break;
      
      case 'impact_assessment':
        analysis.impact = await this.assessMalwareImpact(incident);
        analysis.scope = this.calculateIncidentScope(incident);
        break;
      
      case 'attribution':
        analysis.attribution = this.performAttribution(incident);
        analysis.confidence = 'medium';
        break;
      
      case 'ttps':
        analysis.tactics = this.identifyMitreTactics(incident);
        analysis.techniques = this.identifyMitreTechniques(incident);
        break;
    }

    if (includeNetworkAnalysis) {
      analysis.networkAnalysis = this.analyzeNetworkIndicators(incident);
    }

    if (includeBehaviorAnalysis) {
      analysis.behaviorAnalysis = this.analyzeMalwareBehavior(incident);
    }

    analysis.recommendations = this.generateMalwareRecommendations(incident, analysis);
    
    return analysis;
  }

  /**
   * Analyze IOCs from incident
   */
  private async analyzeIOCs(incident: any): Promise<any[]> {
    // Simplified IOC analysis
    return [
      {
        type: 'hash',
        value: 'sample_hash_' + incident.id,
        confidence: 'high',
        source: 'incident_analysis'
      }
    ];
  }

  /**
   * Find IOC correlations
   */
  private async findIOCCorrelations(incident: any): Promise<any[]> {
    return [
      {
        indicator: 'sample_indicator',
        correlatedIncidents: 2,
        confidence: 'medium'
      }
    ];
  }

  /**
   * Build incident timeline
   */
  private async buildIncidentTimeline(incident: any): Promise<any[]> {
    return [
      {
        timestamp: incident.detectedAt,
        event: 'Malware detected',
        source: 'security_tools'
      },
      {
        timestamp: incident.createdAt,
        event: 'Incident created',
        source: 'soc_team'
      }
    ];
  }

  /**
   * Identify attack phases
   */
  private identifyAttackPhases(incident: any): string[] {
    return ['Initial Access', 'Execution', 'Persistence', 'Impact'];
  }

  /**
   * Assess malware impact
   */
  private async assessMalwareImpact(incident: any): Promise<any> {
    return {
      severity: incident.severity,
      affectedSystems: incident.affectedAssets?.length || 0,
      estimatedDowntime: '2 hours',
      dataCompromised: 'unknown'
    };
  }

  /**
   * Calculate incident scope
   */
  private calculateIncidentScope(incident: any): any {
    return {
      geographical: 'local',
      organizational: 'department',
      technical: 'endpoints'
    };
  }

  /**
   * Perform attribution analysis
   */
  private performAttribution(incident: any): any {
    return {
      suspectedActor: 'Unknown',
      motiviation: 'Financial',
      region: 'Unknown'
    };
  }

  /**
   * Identify MITRE ATT&CK tactics
   */
  private identifyMitreTactics(incident: any): string[] {
    return ['Initial Access', 'Execution', 'Impact'];
  }

  /**
   * Identify MITRE ATT&CK techniques
   */
  private identifyMitreTechniques(incident: any): string[] {
    return ['T1566.001', 'T1059.001', 'T1486'];
  }

  /**
   * Analyze network indicators
   */
  private analyzeNetworkIndicators(incident: any): any {
    return {
      domains: ['suspicious.example.com'],
      ips: ['192.168.1.100'],
      protocols: ['HTTP', 'HTTPS']
    };
  }

  /**
   * Analyze malware behavior
   */
  private analyzeMalwareBehavior(incident: any): any {
    return {
      fileSystemChanges: ['Created encrypted files'],
      registryChanges: ['Modified startup keys'],
      networkActivity: ['C2 communication']
    };
  }

  /**
   * Generate malware-specific recommendations
   */
  private generateMalwareRecommendations(incident: any, analysis: any): string[] {
    return [
      'Isolate affected systems immediately',
      'Update antivirus signatures',
      'Review backup integrity',
      'Implement additional network monitoring'
    ];
  }

  /**
   * Get malware volume trends
   */
  private async getMalwareVolumeTrends(baseWhere: any, timeRange: string): Promise<any> {
    return {
      daily: [
        { date: '2024-01-01', count: 5 },
        { date: '2024-01-02', count: 3 }
      ],
      total: 8,
      trend: 'decreasing'
    };
  }

  /**
   * Get malware family trends  
   */
  private async getMalwareFamilyTrends(baseWhere: any): Promise<any> {
    return {
      families: [
        { name: 'Trojan', count: 15, percentage: 60 },
        { name: 'Ransomware', count: 6, percentage: 24 },
        { name: 'Virus', count: 4, percentage: 16 }
      ]
    };
  }

  /**
   * Get malware geography trends
   */
  private async getMalwareGeographyTrends(baseWhere: any): Promise<any> {
    return {
      regions: [
        { region: 'North America', count: 12 },
        { region: 'Europe', count: 8 },
        { region: 'Asia', count: 5 }
      ]
    };
  }

  /**
   * Get malware target trends
   */
  private async getMalwareTargetTrends(baseWhere: any): Promise<any> {
    return {
      industries: [
        { industry: 'Healthcare', count: 8 },
        { industry: 'Financial', count: 6 },
        { industry: 'Manufacturing', count: 4 }
      ]
    };
  }

  /**
   * Generate trend summary
   */
  private generateTrendSummary(trendData: any, trendType: string): string {
    switch (trendType) {
      case 'volume':
        return `Malware incidents ${trendData.trend} with ${trendData.total} total incidents`;
      case 'family':
        return `Top malware family: ${trendData.families[0]?.name} (${trendData.families[0]?.percentage}%)`;
      default:
        return 'Trend analysis completed';
    }
  }
}

// Export tools and executor
export { MALWARE_ANALYSIS_TOOLS };
export const malwareAnalysisExecutor = new MalwareAnalysisExecutor();
export default malwareAnalysisExecutor;