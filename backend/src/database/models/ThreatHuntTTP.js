const { DataTypes } = require('sequelize');
const sequelize = require('../config/database');

const ThreatHuntTTP = sequelize.define('ThreatHuntTTP', {
  id: {
    type: DataTypes.UUID,
    primaryKey: true,
    defaultValue: DataTypes.UUIDV4,
  },
  
  // === RELATIONSHIP ===
  threatHuntId: {
    type: DataTypes.UUID,
    allowNull: false,
    field: 'threat_hunt_id',
    references: {
      model: 'threat_hunts',
      key: 'id',
    },
    onUpdate: 'CASCADE',
    onDelete: 'CASCADE',
    comment: 'Reference to the threat hunt this TTP belongs to',
  },
  
  // === MITRE ATT&CK IDENTIFICATION ===
  tacticId: {
    type: DataTypes.STRING(20),
    allowNull: false,
    field: 'tactic_id',
    comment: 'MITRE ATT&CK Tactic ID (e.g., TA0001)',
  },
  tacticName: {
    type: DataTypes.STRING(100),
    allowNull: false,
    field: 'tactic_name',
    comment: 'MITRE ATT&CK Tactic name (e.g., Initial Access)',
  },
  techniqueId: {
    type: DataTypes.STRING(20),
    allowNull: false,
    field: 'technique_id',
    comment: 'MITRE ATT&CK Technique ID (e.g., T1566.001)',
  },
  techniqueName: {
    type: DataTypes.STRING(200),
    allowNull: false,
    field: 'technique_name',
    comment: 'MITRE ATT&CK Technique name (e.g., Spearphishing Attachment)',
  },
  subTechnique: {
    type: DataTypes.STRING(100),
    allowNull: true,
    field: 'sub_technique',
    comment: 'Sub-technique specification if applicable',
  },
  
  // === THREAT HUNTING APPROACH ===
  huntingHypothesis: {
    type: DataTypes.TEXT,
    allowNull: true,
    field: 'hunting_hypothesis',
    comment: 'Specific hypothesis for hunting this technique',
  },
  huntingApproach: {
    type: DataTypes.TEXT,
    allowNull: false,
    field: 'hunting_approach',
    comment: 'Detailed methodology for hunting this specific technique',
  },
  detectionStrategy: {
    type: DataTypes.TEXT,
    allowNull: true,
    field: 'detection_strategy',
    comment: 'Strategy for detecting this technique in the environment',
  },
  
  // === DATA SOURCES & QUERIES ===
  dataSources: {
    type: DataTypes.ARRAY(DataTypes.STRING),
    defaultValue: [],
    field: 'data_sources',
    comment: 'Required data sources for hunting this technique',
  },
  huntingQueries: {
    type: DataTypes.JSONB,
    defaultValue: {},
    field: 'hunting_queries',
    comment: 'Platform-specific hunting queries (Splunk, ELK, KQL, etc.)',
  },
  indicators: {
    type: DataTypes.ARRAY(DataTypes.TEXT),
    defaultValue: [],
    comment: 'Key indicators and artifacts to look for',
  },
  
  // === ENVIRONMENTAL CONSIDERATIONS ===
  platforms: {
    type: DataTypes.ARRAY(DataTypes.STRING),
    defaultValue: [],
    comment: 'Target platforms for this technique (Windows, Linux, macOS, etc.)',
  },
  environments: {
    type: DataTypes.ARRAY(DataTypes.STRING),
    defaultValue: [],
    comment: 'Target environments (Enterprise, Cloud, Mobile, etc.)',
  },
  prerequisites: {
    type: DataTypes.ARRAY(DataTypes.TEXT),
    defaultValue: [],
    comment: 'Prerequisites or conditions needed for this technique',
  },
  
  // === ANALYSIS & VALIDATION ===
  falsePositiveConsiderations: {
    type: DataTypes.TEXT,
    allowNull: true,
    field: 'false_positive_considerations',
    comment: 'Known false positive scenarios and mitigation strategies',
  },
  validationCriteria: {
    type: DataTypes.ARRAY(DataTypes.TEXT),
    defaultValue: [],
    field: 'validation_criteria',
    comment: 'Criteria for validating positive findings',
  },
  confidenceLevel: {
    type: DataTypes.ENUM('low', 'medium', 'high', 'very_high'),
    allowNull: false,
    defaultValue: 'medium',
    field: 'confidence_level',
    comment: 'Confidence level in the hunting approach for this technique',
  },
  
  // === RESULTS TRACKING ===
  huntingResults: {
    type: DataTypes.TEXT,
    allowNull: true,
    field: 'hunting_results',
    comment: 'Results and findings specific to this technique',
  },
  evidenceFound: {
    type: DataTypes.ARRAY(DataTypes.TEXT),
    defaultValue: [],
    field: 'evidence_found',
    comment: 'Specific evidence or indicators found for this technique',
  },
  effectivenessRating: {
    type: DataTypes.INTEGER,
    allowNull: true,
    field: 'effectiveness_rating',
    validate: {
      min: 1,
      max: 5,
    },
    comment: 'Effectiveness rating of the hunting approach (1-5)',
  },
  
  // === METADATA ===
  isCustomTechnique: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
    field: 'is_custom_technique',
    comment: 'Whether this is a custom technique beyond MITRE ATT&CK',
  },
  aiGenerated: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
    field: 'ai_generated',
    comment: 'Whether this TTP mapping was generated by AI',
  },
  priority: {
    type: DataTypes.ENUM('low', 'medium', 'high', 'critical'),
    allowNull: false,
    defaultValue: 'medium',
    comment: 'Priority level for hunting this specific technique',
  },
  
  // === AI MAPPING ENHANCEMENT ===
  aiToolCallingSessionId: {
    type: DataTypes.STRING(100),
    allowNull: true,
    field: 'ai_tool_calling_session_id',
    comment: 'Session ID linking to ai_tool_calling_log for AI mapping context',
  },
  aiMappingReasoning: {
    type: DataTypes.TEXT,
    allowNull: true,
    field: 'ai_mapping_reasoning',
    comment: 'AI reasoning for why this technique was mapped to the threat hunt',
  },
  aiConfidenceScore: {
    type: DataTypes.DECIMAL(3, 2),
    allowNull: true,
    field: 'ai_confidence_score',
    validate: {
      min: 0.00,
      max: 1.00,
    },
    comment: 'AI confidence score for this technique mapping (0.00 to 1.00)',
  },
  aiReasoningEffort: {
    type: DataTypes.ENUM('low', 'medium', 'high'),
    allowNull: true,
    field: 'ai_reasoning_effort',
    comment: 'Reasoning effort level used for AI mapping',
  },
  aiMappingTimestamp: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'ai_mapping_timestamp',
    comment: 'When AI mapping was performed',
  },
  aiMappingValidated: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
    field: 'ai_mapping_validated',
    comment: 'Whether the AI mapping has been validated by a human',
  },
  humanValidationNotes: {
    type: DataTypes.TEXT,
    allowNull: true,
    field: 'human_validation_notes',
    comment: 'Human notes on AI mapping validation',
  },
  
  // === ORGANIZATIONAL ===
  organizationId: {
    type: DataTypes.UUID,
    allowNull: false,
    field: 'organization_id',
    references: {
      model: 'organizations',
      key: 'id',
    },
    onUpdate: 'CASCADE',
    onDelete: 'CASCADE',
  },
  
  createdAt: {
    type: DataTypes.DATE,
    allowNull: false,
    field: 'created_at',
  },
  updatedAt: {
    type: DataTypes.DATE,
    allowNull: false,
    field: 'updated_at',
  },
}, {
  tableName: 'threat_hunt_ttps',
  timestamps: true,
  indexes: [
    // Primary relationships
    {
      fields: ['threat_hunt_id'],
      name: 'threat_hunt_ttps_hunt_id_idx'
    },
    {
      fields: ['organization_id'],
      name: 'threat_hunt_ttps_organization_id_idx'
    },
    
    // MITRE ATT&CK lookups
    {
      fields: ['tactic_id'],
      name: 'threat_hunt_ttps_tactic_id_idx'
    },
    {
      fields: ['technique_id'],
      name: 'threat_hunt_ttps_technique_id_idx'
    },
    {
      fields: ['tactic_id', 'technique_id'],
      name: 'threat_hunt_ttps_tactic_technique_idx'
    },
    
    // Filtering and analysis
    {
      fields: ['priority'],
      name: 'threat_hunt_ttps_priority_idx'
    },
    {
      fields: ['confidence_level'],
      name: 'threat_hunt_ttps_confidence_level_idx'
    },
    {
      fields: ['is_custom_technique'],
      name: 'threat_hunt_ttps_is_custom_technique_idx'
    },
    {
      fields: ['ai_generated'],
      name: 'threat_hunt_ttps_ai_generated_idx'
    },
    
    // Array field indexes
    {
      using: 'gin',
      fields: ['data_sources'],
      name: 'threat_hunt_ttps_data_sources_gin_idx'
    },
    {
      using: 'gin',
      fields: ['indicators'],
      name: 'threat_hunt_ttps_indicators_gin_idx'
    },
    {
      using: 'gin',
      fields: ['platforms'],
      name: 'threat_hunt_ttps_platforms_gin_idx'
    },
    {
      using: 'gin',
      fields: ['environments'],
      name: 'threat_hunt_ttps_environments_gin_idx'
    },
    
    // JSONB indexes
    {
      using: 'gin',
      fields: ['hunting_queries'],
      name: 'threat_hunt_ttps_hunting_queries_gin_idx'
    },
    
    // Compound indexes for common queries
    {
      fields: ['threat_hunt_id', 'priority', 'confidence_level'],
      name: 'threat_hunt_ttps_hunt_priority_confidence_idx'
    },
    {
      fields: ['organization_id', 'technique_id'],
      name: 'threat_hunt_ttps_org_technique_idx'
    },
  ],
  comment: 'Enhanced MITRE ATT&CK TTP integration for professional threat hunting',
});

module.exports = ThreatHuntTTP;