# SPDX-FileCopyrightText: Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0

import json
import logging
import time
from typing import Dict, List, Optional
from pydantic.fields import Field
from aiq.builder.framework_enum import LLMFrameworkEnum
from aiq.cli.register_workflow import register_function
from aiq.data_models.component_ref import LLMRef
from aiq.data_models.function import FunctionBaseConfig
from ..core.prompts import ScriptGeneratorPrompts


class ScriptGeneratorConfig(FunctionBaseConfig, name="script_generator"):
    """Configuration for the Script Generator tool."""
    llm_name: LLMRef
    offline_mode: bool = Field(default=True, description="Whether to run in offline mode")
    enable_dangerous_operations: bool = Field(default=False, description="Enable generation of system-level scripts")
    script_safety_level: str = Field(default="safe", description="Script safety level: safe, moderate, advanced")
    max_script_length: int = Field(default=500, description="Maximum lines per generated script")


@register_function(config_type=ScriptGeneratorConfig, framework_wrappers=[LLMFrameworkEnum.LANGCHAIN])
async def script_generator_function(config: ScriptGeneratorConfig, builder):
    """
    Advanced script generator for security automation and threat takedown.
    Generates shell scripts, Python scripts, and PowerShell scripts based on threat context.
    """
    
    from langchain_core.language_models.chat_models import BaseChatModel
    
    llm: BaseChatModel = await builder.get_llm(config.llm_name, wrapper_type=LLMFrameworkEnum.LANGCHAIN)

    def _generate_bash_ioc_blocking_script(iocs: List[Dict], threat_assessment: Dict) -> str:
        """Generate bash script for IOC blocking and network isolation."""
        
        script_header = """#!/bin/bash
# OpenSOC Automated IOC Blocking Script
# Generated by AI Orchestration System
# SECURITY NOTICE: Review before execution in production

set -euo pipefail

echo "Starting OpenSOC IOC Blocking Script..."
echo "Threat Level: {threat_level}"
echo "Risk Score: {risk_score}%"
echo "Timestamp: $(date)"
echo ""

# Create backup of current rules
BACKUP_DIR="/tmp/opensoc_backups/$(date +%Y%m%d_%H%M%S)"
mkdir -p "$BACKUP_DIR"
echo "Backup directory: $BACKUP_DIR"
""".format(
            threat_level=threat_assessment.get('threat_level', 'UNKNOWN'),
            risk_score=threat_assessment.get('risk_score', 0)
        )
        
        script_body = ""
        
        # Generate IOC blocking rules
        for ioc in iocs:
            ioc_value = ioc['value']
            ioc_type = ioc['type']
            
            if ioc_type == 'ip':
                script_body += f"""
# Block malicious IP: {ioc_value}
echo "Blocking IP: {ioc_value}"
iptables -I INPUT -s {ioc_value} -j DROP
iptables -I OUTPUT -d {ioc_value} -j DROP
echo "{ioc_value} # OpenSOC Auto-Block $(date)" >> /tmp/blocked_ips.txt
"""
            elif ioc_type == 'domain':
                script_body += f"""
# Block malicious domain: {ioc_value}
echo "Blocking domain: {ioc_value}"
echo "127.0.0.1 {ioc_value}" >> /etc/hosts
echo "{ioc_value} # OpenSOC Auto-Block $(date)" >> /tmp/blocked_domains.txt
"""
        
        script_footer = """
echo ""
echo "IOC blocking completed successfully"
echo "Review blocked items in /tmp/blocked_*.txt"
echo "To undo changes, restore from backup: $BACKUP_DIR"
echo "Script execution completed at: $(date)"
"""
        
        return script_header + script_body + script_footer

    def _generate_python_automation_script(iocs: List[Dict], threat_assessment: Dict) -> str:
        """Generate Python script for advanced automation and API integration."""
        
        script = f'''#!/usr/bin/env python3
"""
OpenSOC Advanced Automation Script
Generated by AI Orchestration System
Threat Level: {threat_assessment.get('threat_level', 'UNKNOWN')}
Risk Score: {threat_assessment.get('risk_score', 0)}%
"""

import requests
import json
import time
import logging
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class ThreatMitigationAutomator:
    def __init__(self):
        self.blocked_iocs = []
        self.execution_log = []
        self.start_time = time.time()
        
    def log_action(self, action, status, details=""):
        """Log automation actions for audit trail."""
        log_entry = {{
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "status": status,
            "details": details
        }}
        self.execution_log.append(log_entry)
        logging.info(f"Action: {{action}} - Status: {{status}} - {{details}}")
    
    def block_network_iocs(self, iocs):
        """Block malicious IOCs at network level."""
        self.log_action("ioc_blocking_start", "initiated", f"Processing {{len(iocs)}} IOCs")
        
        for ioc in iocs:
            ioc_value = ioc['value']
            ioc_type = ioc['type']
            
            try:
                if ioc_type == 'ip':
                    # Simulate firewall rule addition
                    self.log_action("block_ip", "simulated", f"Would block IP: {{ioc_value}}")
                    self.blocked_iocs.append(ioc)
                elif ioc_type == 'domain':
                    # Simulate DNS blocking
                    self.log_action("block_domain", "simulated", f"Would block domain: {{ioc_value}}")
                    self.blocked_iocs.append(ioc)
                    
                time.sleep(0.1)  # Rate limiting
                
            except Exception as e:
                self.log_action("block_error", "failed", f"Error blocking {{ioc_value}}: {{e}}")
    
    def generate_incident_report(self):
        """Generate automation execution report."""
        execution_time = time.time() - self.start_time
        
        report = {{
            "execution_summary": {{
                "total_iocs_processed": len(self.blocked_iocs),
                "execution_time_seconds": round(execution_time, 2),
                "threat_level": "{threat_assessment.get('threat_level', 'UNKNOWN')}",
                "automation_status": "completed"
            }},
            "blocked_iocs": self.blocked_iocs,
            "execution_log": self.execution_log,
            "recommendations": [
                "Verify all blocked IOCs are correct",
                "Monitor for bypass attempts",
                "Update security signatures",
                "Review automation effectiveness"
            ]
        }}
        
        return json.dumps(report, indent=2)

def main():
    """Main automation execution."""
    automator = ThreatMitigationAutomator()
    
    # IOCs to process
    iocs_to_block = {json.dumps(extracted_iocs, indent=8) if 'extracted_iocs' in locals() else '[]'}
    
    try:
        automator.log_action("automation_start", "initiated", "OpenSOC orchestration automation")
        automator.block_network_iocs(iocs_to_block)
        
        # Generate final report
        report = automator.generate_incident_report()
        print("\\n=== AUTOMATION EXECUTION REPORT ===")
        print(report)
        
        automator.log_action("automation_complete", "success", "All automation tasks completed")
        
    except Exception as e:
        automator.log_action("automation_error", "failed", f"Critical error: {{e}}")
        logging.error(f"Automation failed: {{e}}")
        return 1
    
    return 0

if __name__ == "__main__":
    exit(main())
'''
        
        return script

    def _generate_powershell_automation_script(iocs: List[Dict], threat_assessment: Dict) -> str:
        """Generate PowerShell script for Windows-based threat mitigation."""
        
        script = f'''# OpenSOC PowerShell Automation Script
# Generated by AI Orchestration System
# Threat Level: {threat_assessment.get('threat_level', 'UNKNOWN')}
# Risk Score: {threat_assessment.get('risk_score', 0)}%

param(
    [switch]$WhatIf = $false,
    [switch]$Verbose = $false
)

$ErrorActionPreference = "Stop"

Write-Host "Starting OpenSOC PowerShell Automation..." -ForegroundColor Green
Write-Host "Threat Level: {threat_assessment.get('threat_level', 'UNKNOWN')}" -ForegroundColor Yellow
Write-Host "Risk Score: {threat_assessment.get('risk_score', 0)}%" -ForegroundColor Yellow
Write-Host "Timestamp: $(Get-Date)" -ForegroundColor Gray
Write-Host ""

# Initialize logging
$LogPath = "$env:TEMP\\OpenSOC_Automation_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
Start-Transcript -Path $LogPath

try {{
    # Create backup of current security settings
    $BackupPath = "$env:TEMP\\OpenSOC_Backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
    New-Item -ItemType Directory -Path $BackupPath -Force | Out-Null
    Write-Host "Backup directory: $BackupPath" -ForegroundColor Cyan
    
    # IOC blocking functions
    function Block-MaliciousIP {{
        param([string]$IPAddress)
        
        if ($WhatIf) {{
            Write-Host "WHATIF: Would block IP $IPAddress" -ForegroundColor Yellow
        }} else {{
            Write-Host "Blocking IP: $IPAddress" -ForegroundColor Red
            # New-NetFirewallRule -DisplayName "OpenSOC-Block-$IPAddress" -Direction Outbound -RemoteAddress $IPAddress -Action Block
            # New-NetFirewallRule -DisplayName "OpenSOC-Block-$IPAddress-In" -Direction Inbound -RemoteAddress $IPAddress -Action Block
            Add-Content -Path "$BackupPath\\blocked_ips.txt" -Value "$IPAddress # Blocked by OpenSOC $(Get-Date)"
        }}
    }}
    
    function Block-MaliciousDomain {{
        param([string]$Domain)
        
        if ($WhatIf) {{
            Write-Host "WHATIF: Would block domain $Domain" -ForegroundColor Yellow  
        }} else {{
            Write-Host "Blocking domain: $Domain" -ForegroundColor Red
            # Add-Content -Path "$env:SystemRoot\\System32\\drivers\\etc\\hosts" -Value "127.0.0.1 $Domain # OpenSOC Auto-Block"
            Add-Content -Path "$BackupPath\\blocked_domains.txt" -Value "$Domain # Blocked by OpenSOC $(Get-Date)"
        }}
    }}
    
    # Process IOCs'''
        
        # Add IOC processing
        for ioc in iocs:
            ioc_value = ioc['value']
            ioc_type = ioc['type']
            
            if ioc_type == 'ip':
                script += f'\n    Block-MaliciousIP -IPAddress "{ioc_value}"'
            elif ioc_type == 'domain':
                script += f'\n    Block-MaliciousDomain -Domain "{ioc_value}"'
        
        script += '''
    
    Write-Host ""
    Write-Host "IOC blocking completed successfully" -ForegroundColor Green
    Write-Host "Review blocked items in: $BackupPath" -ForegroundColor Cyan
    Write-Host "Execution log: $LogPath" -ForegroundColor Cyan
    
}} catch {
    Write-Error "Automation script failed: $($_.Exception.Message)"
    exit 1
} finally {
    Stop-Transcript
    Write-Host "Script execution completed at: $(Get-Date)" -ForegroundColor Gray
}'''
        
        return script

    def _validate_script_safety(script_content: str, language: str) -> Dict:
        """Validate generated scripts for safety and security."""
        
        safety_issues = []
        risk_level = "low"
        
        dangerous_patterns = {
            'bash': [
                r'rm\s+-rf\s+/',
                r'mkfs\.',
                r'dd\s+if=.*of=/dev/',
                r'>\s*/dev/sd[a-z]',
                r'chmod\s+777'
            ],
            'powershell': [
                r'Remove-Item.*-Recurse.*-Force',
                r'Format-Volume',
                r'Clear-Disk',
                r'Set-ExecutionPolicy\s+Unrestricted'
            ],
            'python': [
                r'os\.system\(["\']rm\s+-rf',
                r'subprocess\.call\(["\']format',
                r'open\(["\']/.*/.*["\'].*["\']w'
            ]
        }
        
        patterns = dangerous_patterns.get(language, [])
        for pattern in patterns:
            import re
            if re.search(pattern, script_content, re.IGNORECASE):
                safety_issues.append(f"Potentially dangerous operation detected: {pattern}")
                risk_level = "high"
        
        return {
            "is_safe": len(safety_issues) == 0,
            "risk_level": risk_level,
            "safety_issues": safety_issues,
            "validation_timestamp": time.strftime('%Y-%m-%d %H:%M:%S UTC')
        }

    async def generate_automation_scripts(threat_data: str, script_language: str = "bash", asset_context: str = "") -> str:
        """
        Generate automation scripts for threat mitigation and takedown.
        
        Args:
            threat_data: JSON string containing threat assessment and IOC data
            script_language: Target script language (bash, python, powershell)
            asset_context: Asset information for context-aware script generation
            
        Returns:
            Generated scripts with safety validation and execution guidance
        """
        
        try:
            start_time = time.time()
            
            # Parse threat data
            threat_info = json.loads(threat_data) if isinstance(threat_data, str) else threat_data
            threat_assessment = threat_info.get('threat_assessment', {})
            extracted_iocs = threat_info.get('extracted_iocs', [])
            
            logging.info(f"Generating {script_language} scripts for {len(extracted_iocs)} IOCs")
            
            generated_scripts = {}
            validation_results = {}
            
            # Generate primary automation script
            if script_language == 'bash':
                primary_script = _generate_bash_ioc_blocking_script(extracted_iocs, threat_assessment)
                script_name = "ioc_blocking_automation.sh"
            elif script_language == 'python':
                primary_script = _generate_python_automation_script(extracted_iocs, threat_assessment)
                script_name = "threat_mitigation_automation.py"
            elif script_language == 'powershell':
                primary_script = _generate_powershell_automation_script(extracted_iocs, threat_assessment)
                script_name = "IOC-Blocking-Automation.ps1"
            else:
                return json.dumps({
                    "status": "error",
                    "error": f"Unsupported script language: {script_language}",
                    "supported_languages": ["bash", "python", "powershell"]
                })
            
            generated_scripts[script_name] = {
                "content": primary_script,
                "language": script_language,
                "type": "primary_automation",
                "description": f"Main IOC blocking and threat mitigation script ({script_language})",
                "execution_priority": 1
            }
            
            # Validate script safety
            if config.script_safety_validation:
                validation = _validate_script_safety(primary_script, script_language)
                validation_results[script_name] = validation
            
            # Generate additional utility scripts
            if script_language == 'bash':
                # Network monitoring script
                monitoring_script = f'''#!/bin/bash
# OpenSOC Network Monitoring Script
# Monitor for continued threat activity

echo "Starting network monitoring for threat indicators..."

# Monitor for blocked IOCs trying to reconnect
while true; do
    echo "$(date): Checking for threat activity..."
    
{chr(10).join(f'    netstat -an | grep {ioc["value"]} && echo "WARNING: Continued activity from {ioc["value"]}"' for ioc in extracted_iocs if ioc["type"] == "ip")}
    
    sleep 300  # Check every 5 minutes
done
'''
                generated_scripts["network_monitoring.sh"] = {
                    "content": monitoring_script,
                    "language": "bash",
                    "type": "monitoring",
                    "description": "Continuous network monitoring for threat indicators",
                    "execution_priority": 2
                }
            
            # Generate execution summary
            processing_time = time.time() - start_time
            
            script_generation_results = {
                "status": "completed",
                "generated_scripts": generated_scripts,
                "validation_results": validation_results,
                "script_statistics": {
                    "total_scripts": len(generated_scripts),
                    "primary_language": script_language,
                    "total_lines": sum(len(script["content"].split('\\n')) for script in generated_scripts.values()),
                    "iocs_addressed": len(extracted_iocs),
                    "threat_level": threat_assessment.get('threat_level', 'UNKNOWN')
                },
                "execution_guidance": {
                    "review_required": True,
                    "backup_recommended": True,
                    "test_environment_first": True,
                    "execution_order": [name for name, script in sorted(generated_scripts.items(), key=lambda x: x[1]["execution_priority"])]
                },
                "processing_time_ms": round(processing_time * 1000),
                "generation_timestamp": time.strftime('%Y-%m-%d %H:%M:%S UTC')
            }
            
            logging.info(f"Script generation completed in {processing_time:.2f}s")
            return json.dumps(script_generation_results, indent=2)
            
        except Exception as e:
            error_result = {
                "status": "failed",
                "error": str(e),
                "error_type": type(e).__name__,
                "processing_time_ms": round((time.time() - start_time) * 1000) if 'start_time' in locals() else 0
            }
            
            logging.error(f"Script generation failed: {e}")
            return json.dumps(error_result, indent=2)

    yield generate_automation_scripts